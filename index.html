<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Latte Flow Mobile MVP</title>
  <style>
    :root {
      --bg: #f3e3cc;
      --coffee: #6d3d26;
      --foam: #f8f5ee;
      --ui: #2f1e14;
      --ui-soft: #6f4a35;
      --accent: #c87937;
      --danger: #bb3e03;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at 20% 10%, #fff2dd 0%, var(--bg) 55%, #dfc5a5 100%);
      color: var(--ui);
      font-family: "Avenir Next", "Segoe UI", sans-serif;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }

    #app {
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 8px;
      height: 100dvh;
      padding: max(8px, env(safe-area-inset-top)) 10px max(10px, env(safe-area-inset-bottom));
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      background: rgba(255, 248, 236, 0.9);
      border: 1px solid #cfb08f;
      border-radius: 12px;
      padding: 8px;
      font-size: 13px;
    }

    .chip {
      background: #fff5e8;
      border: 1px solid #d3b28f;
      border-radius: 999px;
      padding: 5px 10px;
      white-space: nowrap;
    }

    .main {
      display: grid;
      grid-template-columns: 1fr 74px;
      gap: 8px;
      min-height: 0;
    }

    .cup-wrap {
      position: relative;
      border-radius: 18px;
      border: 2px solid #2e2016;
      background: linear-gradient(155deg, #fdf1e2 0%, #efd0ad 70%);
      box-shadow: inset 0 0 0 6px rgba(255, 243, 224, 0.75);
      overflow: hidden;
      min-height: 0;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .overlay {
      position: absolute;
      left: 8px;
      right: 8px;
      bottom: 8px;
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #f9e6cf;
      text-shadow: 0 1px 2px #000;
      pointer-events: none;
    }

    .controls {
      display: grid;
      grid-template-rows: 1fr auto auto;
      gap: 8px;
      min-height: 0;
    }

    .flow {
      border-radius: 16px;
      background: rgba(255, 248, 236, 0.96);
      border: 1px solid #c9aa89;
      padding: 8px 6px;
      display: flex;
      justify-content: center;
      min-height: 0;
    }

    #flowSlider {
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
      width: 48px;
      height: 100%;
      min-height: 220px;
    }

    .btn {
      min-height: 46px;
      border: 0;
      border-radius: 12px;
      background: var(--ui-soft);
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.2px;
      padding: 10px 6px;
    }

    .btn:active { transform: scale(0.98); }

    .btn.alt { background: var(--accent); }
    .btn.warn { background: var(--danger); }

    .footer {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .footer .btn { min-height: 50px; }

    @media (orientation: portrait) {
      .main { grid-template-columns: 1fr 70px; }
      .topbar { font-size: 12px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="topbar">
      <span class="chip" id="lessonChip">Lesson: Dot Control</span>
      <span class="chip" id="scoreChip">Score: 0</span>
      <span class="chip" id="tiltChip">Tilt: Off</span>
    </div>

    <div class="main">
      <div class="cup-wrap" id="cupWrap">
        <canvas id="latte"></canvas>
        <div class="overlay">
          <span>Drag to pour</span>
          <span>Tap for cut-through</span>
        </div>
      </div>

      <div class="controls">
        <div class="flow">
          <input id="flowSlider" type="range" min="0" max="100" value="35" />
        </div>
        <button class="btn alt" id="tiltBtn">Enable Tilt</button>
        <button class="btn warn" id="clearBtn">Reset Cup</button>
      </div>
    </div>

    <div class="footer">
      <button class="btn" id="prevBtn">Prev Shape</button>
      <button class="btn" id="nextBtn">Next Shape</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("latte");
    const ctx = canvas.getContext("2d", { alpha: false });
    const offCanvas = document.createElement("canvas");
    const offCtx = offCanvas.getContext("2d", { alpha: false });
    const cupWrap = document.getElementById("cupWrap");
    const flowSlider = document.getElementById("flowSlider");
    const clearBtn = document.getElementById("clearBtn");
    const tiltBtn = document.getElementById("tiltBtn");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const lessonChip = document.getElementById("lessonChip");
    const scoreChip = document.getElementById("scoreChip");
    const tiltChip = document.getElementById("tiltChip");

    const lessons = ["Dot Control", "Heart", "Tulip", "Rosetta", "Swan"];
    let lessonIndex = 0;

    const state = {
      dpr: Math.max(1, window.devicePixelRatio || 1),
      pouring: false,
      pointerX: 0,
      pointerY: 0,
      flow: Number(flowSlider.value) / 100,
      tilt: 0,
      tiltEnabled: false,
      wasTap: false,
      milkQuality: 0.88,
      score: 0,
      lastTime: performance.now()
    };

    const grid = {
      w: 180,
      h: 180,
      brown: new Float32Array(180 * 180),
      white: new Float32Array(180 * 180),
      nextBrown: new Float32Array(180 * 180),
      nextWhite: new Float32Array(180 * 180)
    };
    const img = new ImageData(grid.w, grid.h);

    function idx(x, y) { return y * grid.w + x; }

    function resetCup() {
      grid.brown.fill(0.88);
      grid.white.fill(0);
      renderCup();
      recalcScore();
    }

    function resize() {
      const rect = cupWrap.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * state.dpr);
      canvas.height = Math.floor(rect.height * state.dpr);
      canvas.style.width = rect.width + "px";
      canvas.style.height = rect.height + "px";
      renderCup();
    }

    function toGrid(px, py) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.max(0, Math.min(1, (px - rect.left) / rect.width));
      const y = Math.max(0, Math.min(1, (py - rect.top) / rect.height));
      return {
        x: Math.floor(x * (grid.w - 1)),
        y: Math.floor(y * (grid.h - 1))
      };
    }

    function pourAt(gx, gy, dt) {
      const base = 1.4 + state.flow * 5.8;
      const radius = Math.max(1.6, 1.2 + state.flow * 4.8 - Math.abs(state.tilt) * 2.4);
      const jitter = (1 - state.milkQuality) * 0.8;

      const minX = Math.max(1, Math.floor(gx - radius * 1.8));
      const maxX = Math.min(grid.w - 2, Math.ceil(gx + radius * 1.8));
      const minY = Math.max(1, Math.floor(gy - radius * 1.8));
      const maxY = Math.min(grid.h - 2, Math.ceil(gy + radius * 1.8));

      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const dx = x - gx + (Math.random() - 0.5) * jitter;
          const dy = y - gy;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d > radius) continue;

          const falloff = 1 - d / radius;
          const push = base * falloff * dt;
          const i = idx(x, y);

          const addedWhite = Math.min(1, grid.white[i] + push * 0.075);
          grid.white[i] = addedWhite;
          grid.brown[i] = Math.max(0.12, grid.brown[i] - push * 0.05);

          const driftX = Math.round(state.tilt * 2.0 * (0.3 + state.flow));
          const ni = idx(Math.max(0, Math.min(grid.w - 1, x + driftX)), y);
          grid.white[ni] = Math.min(1, grid.white[ni] + push * 0.02);
        }
      }
    }

    function cutThrough(gx, gy) {
      const r = 3;
      for (let y = Math.max(0, gy - r); y < Math.min(grid.h, gy + r); y++) {
        for (let x = Math.max(0, gx - r); x < Math.min(grid.w, gx + r); x++) {
          const i = idx(x, y);
          grid.white[i] *= 0.25;
          grid.brown[i] = Math.min(1, grid.brown[i] + 0.28);
        }
      }
    }

    function simulate(dt) {
      const diff = 0.045;
      const adv = state.tilt * 0.4;
      for (let y = 1; y < grid.h - 1; y++) {
        for (let x = 1; x < grid.w - 1; x++) {
          const i = idx(x, y);
          const l = idx(x - 1, y);
          const r = idx(x + 1, y);
          const u = idx(x, y - 1);
          const d = idx(x, y + 1);

          const lapWhite = grid.white[l] + grid.white[r] + grid.white[u] + grid.white[d] - grid.white[i] * 4;
          const lapBrown = grid.brown[l] + grid.brown[r] + grid.brown[u] + grid.brown[d] - grid.brown[i] * 4;

          let nw = grid.white[i] + lapWhite * diff * dt * 60;
          let nb = grid.brown[i] + lapBrown * diff * dt * 60;

          const from = idx(Math.max(0, Math.min(grid.w - 1, x - Math.round(adv))), y);
          nw = nw * 0.88 + grid.white[from] * 0.12;

          nw = Math.max(0, Math.min(1, nw * 0.998));
          nb = Math.max(0, Math.min(1, nb * 0.999));

          grid.nextWhite[i] = nw;
          grid.nextBrown[i] = nb;
        }
      }

      for (let y = 1; y < grid.h - 1; y++) {
        for (let x = 1; x < grid.w - 1; x++) {
          const i = idx(x, y);
          grid.white[i] = grid.nextWhite[i];
          grid.brown[i] = grid.nextBrown[i];
        }
      }
    }

    function targetMask(xn, yn) {
      const cx = 0.5;
      const cy = 0.56;
      if (lessonIndex === 0) {
        const d = Math.hypot(xn - 0.5, yn - 0.53);
        return d < 0.09 ? 1 : 0;
      }
      if (lessonIndex === 1) {
        const d1 = Math.hypot(xn - 0.45, yn - cy);
        const d2 = Math.hypot(xn - 0.55, yn - cy);
        const tip = (Math.abs(xn - cx) < 0.05 && yn > 0.58 && yn < 0.72) ? 1 : 0;
        return (d1 < 0.13 || d2 < 0.13 || tip) ? 1 : 0;
      }
      if (lessonIndex === 2) {
        const b1 = Math.hypot(xn - 0.5, yn - 0.66) < 0.12;
        const b2 = Math.hypot(xn - 0.5, yn - 0.54) < 0.1;
        const b3 = Math.hypot(xn - 0.5, yn - 0.44) < 0.08;
        return (b1 || b2 || b3) ? 1 : 0;
      }
      if (lessonIndex === 3) {
        const spine = Math.abs(xn - 0.5) < 0.03 && yn > 0.36 && yn < 0.72;
        const wave = Math.sin((yn - 0.34) * 40) * 0.08;
        const wing = Math.abs(xn - (0.5 + wave)) < 0.055 && yn > 0.35 && yn < 0.73;
        return (spine || wing) ? 1 : 0;
      }
      const neck = Math.abs(xn - 0.56) < 0.03 && yn > 0.35 && yn < 0.63;
      const body = Math.hypot(xn - 0.48, yn - 0.6) < 0.15;
      const head = Math.hypot(xn - 0.59, yn - 0.33) < 0.055;
      return (neck || body || head) ? 1 : 0;
    }

    function recalcScore() {
      let hit = 0;
      let target = 0;
      let extra = 0;
      for (let y = 0; y < grid.h; y += 2) {
        for (let x = 0; x < grid.w; x += 2) {
          const xn = x / (grid.w - 1);
          const yn = y / (grid.h - 1);
          const t = targetMask(xn, yn);
          const i = idx(x, y);
          const isWhite = grid.white[i] > 0.24;
          if (t) {
            target++;
            if (isWhite) hit++;
          } else if (isWhite) {
            extra++;
          }
        }
      }
      const acc = target > 0 ? hit / target : 0;
      const penalty = Math.min(0.4, extra / (target + 1));
      state.score = Math.max(0, Math.round((acc - penalty) * 100));
      scoreChip.textContent = `Score: ${state.score}`;
    }

    function drawTargetOverlay() {
      const w = canvas.width;
      const h = canvas.height;
      ctx.save();
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = "#f7e8cf";

      for (let y = 0; y < grid.h; y += 2) {
        for (let x = 0; x < grid.w; x += 2) {
          const xn = x / (grid.w - 1);
          const yn = y / (grid.h - 1);
          if (!targetMask(xn, yn)) continue;
          const px = (x / (grid.w - 1)) * w;
          const py = (y / (grid.h - 1)) * h;
          ctx.fillRect(px, py, (w / grid.w) * 1.8, (h / grid.h) * 1.8);
        }
      }
      ctx.restore();
    }

    function renderCup() {
      for (let y = 0; y < grid.h; y++) {
        for (let x = 0; x < grid.w; x++) {
          const i = idx(x, y);
          const p = i * 4;
          const white = grid.white[i];
          const brown = grid.brown[i];

          const r = Math.round(109 * brown + 248 * white);
          const g = Math.round(61 * brown + 245 * white);
          const b = Math.round(38 * brown + 236 * white);

          img.data[p] = r;
          img.data[p + 1] = g;
          img.data[p + 2] = b;
          img.data[p + 3] = 255;
        }
      }

      offCtx.putImageData(img, 0, 0);

      ctx.imageSmoothingEnabled = true;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(offCanvas, 0, 0, canvas.width, canvas.height);
      drawTargetOverlay();

      if (state.pouring) {
        const px = (state.pointerX / (grid.w - 1)) * canvas.width;
        const py = (state.pointerY / (grid.h - 1)) * canvas.height;
        ctx.beginPath();
        ctx.arc(px, py, 7 * state.dpr, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.fill();
      }
    }

    function updateLesson() {
      lessonChip.textContent = `Lesson: ${lessons[lessonIndex]}`;
      recalcScore();
      renderCup();
    }

    function onPointerDown(e) {
      e.preventDefault();
      const g = toGrid(e.clientX, e.clientY);
      state.pouring = true;
      state.pointerX = g.x;
      state.pointerY = g.y;
      state.wasTap = true;
      if (navigator.vibrate) navigator.vibrate(8);
    }

    function onPointerMove(e) {
      if (!state.pouring) return;
      e.preventDefault();
      const g = toGrid(e.clientX, e.clientY);
      const dist = Math.hypot(g.x - state.pointerX, g.y - state.pointerY);
      if (dist > 1.5) state.wasTap = false;
      state.pointerX = g.x;
      state.pointerY = g.y;
    }

    function onPointerUp(e) {
      if (!state.pouring) return;
      e.preventDefault();
      state.pouring = false;
      if (state.wasTap) {
        const g = toGrid(e.clientX, e.clientY);
        cutThrough(g.x, g.y);
        if (navigator.vibrate) navigator.vibrate(12);
      }
      recalcScore();
      renderCup();
    }

    function bindTilt() {
      tiltBtn.addEventListener("click", async () => {
        if (state.tiltEnabled) {
          state.tiltEnabled = false;
          state.tilt = 0;
          tiltChip.textContent = "Tilt: Off";
          tiltBtn.textContent = "Enable Tilt";
          return;
        }

        const needsPermission = typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function";

        if (needsPermission) {
          try {
            const res = await DeviceOrientationEvent.requestPermission();
            if (res !== "granted") return;
          } catch (_) {
            return;
          }
        }

        state.tiltEnabled = true;
        tiltChip.textContent = "Tilt: On";
        tiltBtn.textContent = "Disable Tilt";
      });

      window.addEventListener("deviceorientation", (e) => {
        if (!state.tiltEnabled) return;
        const gamma = e.gamma || 0;
        state.tilt = Math.max(-1, Math.min(1, gamma / 32));
      }, true);
    }

    function loop(now) {
      const dt = Math.min(0.04, (now - state.lastTime) / 1000);
      state.lastTime = now;

      state.flow = Number(flowSlider.value) / 100;

      if (state.pouring) {
        pourAt(state.pointerX, state.pointerY, dt * 60);
      }

      simulate(dt);
      if ((now % 500) < 16) recalcScore();
      renderCup();

      requestAnimationFrame(loop);
    }

    canvas.addEventListener("pointerdown", onPointerDown, { passive: false });
    canvas.addEventListener("pointermove", onPointerMove, { passive: false });
    window.addEventListener("pointerup", onPointerUp, { passive: false });

    clearBtn.addEventListener("click", resetCup);
    prevBtn.addEventListener("click", () => {
      lessonIndex = (lessonIndex - 1 + lessons.length) % lessons.length;
      updateLesson();
    });
    nextBtn.addEventListener("click", () => {
      lessonIndex = (lessonIndex + 1) % lessons.length;
      updateLesson();
    });

    window.addEventListener("resize", resize);
    bindTilt();
    offCanvas.width = grid.w;
    offCanvas.height = grid.h;
    resetCup();
    resize();
    updateLesson();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
