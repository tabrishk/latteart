<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Latte Flow Pitcher Mode</title>
  <style>
    :root {
      --bg: #f3e3cc;
      --ui: #2f1e14;
      --ui-soft: #6f4a35;
      --accent: #c87937;
      --danger: #bb3e03;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at 20% 10%, #fff2dd 0%, var(--bg) 55%, #dfc5a5 100%);
      color: var(--ui);
      font-family: "Avenir Next", "Segoe UI", sans-serif;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }

    #app {
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 8px;
      height: 100dvh;
      padding: max(8px, env(safe-area-inset-top)) 10px max(10px, env(safe-area-inset-bottom));
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      background: rgba(255, 248, 236, 0.92);
      border: 1px solid #cfb08f;
      border-radius: 12px;
      padding: 8px;
      font-size: 12px;
    }

    .chip {
      background: #fff5e8;
      border: 1px solid #d3b28f;
      border-radius: 999px;
      padding: 5px 10px;
      white-space: nowrap;
    }

    .main {
      display: grid;
      grid-template-columns: 1fr 78px;
      gap: 8px;
      min-height: 0;
    }

    .cup-wrap {
      position: relative;
      border-radius: 18px;
      border: 2px solid #2e2016;
      background: linear-gradient(155deg, #fdf1e2 0%, #efd0ad 70%);
      box-shadow: inset 0 0 0 6px rgba(255, 243, 224, 0.75);
      overflow: hidden;
      min-height: 0;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay {
      position: absolute;
      left: 8px;
      right: 8px;
      bottom: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
      color: #f9e6cf;
      text-shadow: 0 1px 2px #000;
      pointer-events: none;
      line-height: 1.2;
    }

    .controls {
      display: grid;
      grid-template-rows: 1fr auto auto auto auto auto;
      gap: 8px;
      min-height: 0;
    }

    .flow {
      border-radius: 16px;
      background: rgba(255, 248, 236, 0.96);
      border: 1px solid #c9aa89;
      padding: 8px 6px;
      display: flex;
      justify-content: center;
      min-height: 0;
    }

    #assistSlider {
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
      width: 48px;
      height: 100%;
      min-height: 180px;
    }

    .btn {
      min-height: 44px;
      border: 0;
      border-radius: 12px;
      background: var(--ui-soft);
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      padding: 10px 6px;
    }

    .btn:active { transform: scale(0.98); }
    .btn.alt { background: var(--accent); }
    .btn.warn { background: var(--danger); }

    .footer {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
    }

    .footer .btn { min-height: 48px; }

    @media (orientation: portrait) {
      .main { grid-template-columns: 1fr 72px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="topbar">
      <span class="chip" id="lessonChip">Lesson: Dot Control</span>
      <span class="chip" id="scoreChip">Score: 0</span>
      <span class="chip" id="motionChip">Pitcher: Off</span>
    </div>

    <div class="main">
      <div class="cup-wrap" id="cupWrap">
        <canvas id="latte"></canvas>
        <div class="overlay">
          <span id="hintPrimary">Tap "Enable Pitcher" then calibrate neutral grip</span>
          <span id="hintSecondary">Tilt forward to pour, roll left-right to draw</span>
        </div>
      </div>

      <div class="controls">
        <div class="flow">
          <input id="assistSlider" type="range" min="0" max="100" value="45" />
        </div>
        <button class="btn alt" id="pitcherBtn">Enable Pitcher</button>
        <button class="btn" id="calibrateBtn">Calibrate Grip</button>
        <button class="btn" id="flipRollBtn">Flip Roll</button>
        <button class="btn" id="flipPourBtn">Flip Pour</button>
        <button class="btn warn" id="clearBtn">Reset Cup</button>
      </div>
    </div>

    <div class="footer">
      <button class="btn" id="prevBtn">Prev Shape</button>
      <button class="btn alt" id="tutorialBtn">Start Tutorial</button>
      <button class="btn" id="nextBtn">Next Shape</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("latte");
    const ctx = canvas.getContext("2d", { alpha: false });
    const offCanvas = document.createElement("canvas");
    const offCtx = offCanvas.getContext("2d", { alpha: false });

    const cupWrap = document.getElementById("cupWrap");
    const assistSlider = document.getElementById("assistSlider");
    const pitcherBtn = document.getElementById("pitcherBtn");
    const calibrateBtn = document.getElementById("calibrateBtn");
    const flipRollBtn = document.getElementById("flipRollBtn");
    const flipPourBtn = document.getElementById("flipPourBtn");
    const clearBtn = document.getElementById("clearBtn");
    const prevBtn = document.getElementById("prevBtn");
    const tutorialBtn = document.getElementById("tutorialBtn");
    const nextBtn = document.getElementById("nextBtn");
    const lessonChip = document.getElementById("lessonChip");
    const scoreChip = document.getElementById("scoreChip");
    const motionChip = document.getElementById("motionChip");
    const hintPrimary = document.getElementById("hintPrimary");
    const hintSecondary = document.getElementById("hintSecondary");

    const lessons = ["Dot Control", "Heart", "Tulip", "Rosetta", "Swan"];
    let lessonIndex = 0;

    const state = {
      dpr: Math.max(1, window.devicePixelRatio || 1),
      pointerX: 90,
      pointerY: 90,
      pourFlow: 0,
      pouring: false,
      tilt: 0,
      milkQuality: 0.92,
      score: 0,
      lastTime: performance.now(),
      pitcherEnabled: false,
      sensorOk: false,
      beta: null,
      gamma: null,
      neutralBeta: 0,
      neutralGamma: 0,
      rhythmFlips: 0,
      lastPitchSign: 0,
      lastFlow: 0,
      rhythmBonus: 0,
      rollSign: 1,
      pourSign: 1,
      tutorialActive: false,
      tutorialT: 0,
      tutorialDuration: 6
    };

    const grid = {
      w: 180,
      h: 180,
      brown: new Float32Array(180 * 180),
      white: new Float32Array(180 * 180),
      nextBrown: new Float32Array(180 * 180),
      nextWhite: new Float32Array(180 * 180)
    };

    const img = new ImageData(grid.w, grid.h);
    let targetCache = new Uint8Array(grid.w * grid.h);

    function idx(x, y) { return y * grid.w + x; }

    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    function inEllipse(x, y, cx, cy, rx, ry) {
      const dx = (x - cx) / rx;
      const dy = (y - cy) / ry;
      return dx * dx + dy * dy <= 1;
    }

    function pointToSegmentDistance(x, y, x1, y1, x2, y2) {
      const vx = x2 - x1;
      const vy = y2 - y1;
      const wx = x - x1;
      const wy = y - y1;
      const vv = vx * vx + vy * vy || 1e-8;
      const t = clamp((wx * vx + wy * vy) / vv, 0, 1);
      const px = x1 + t * vx;
      const py = y1 + t * vy;
      return Math.hypot(x - px, y - py);
    }

    function inThickPolyline(x, y, points, thickness) {
      for (let i = 0; i < points.length - 1; i++) {
        const a = points[i];
        const b = points[i + 1];
        if (pointToSegmentDistance(x, y, a[0], a[1], b[0], b[1]) <= thickness) return true;
      }
      return false;
    }

    function targetMask(xn, yn) {
      if (lessonIndex === 0) {
        return Math.hypot(xn - 0.5, yn - 0.55) < 0.08 ? 1 : 0;
      }
      if (lessonIndex === 1) {
        const lobeL = inEllipse(xn, yn, 0.455, 0.515, 0.105, 0.092);
        const lobeR = inEllipse(xn, yn, 0.545, 0.515, 0.105, 0.092);
        const lowerBody = inEllipse(xn, yn, 0.5, 0.605, 0.104, 0.116);
        const cleft = inEllipse(xn, yn, 0.5, 0.46, 0.046, 0.038);
        const tip = inThickPolyline(xn, yn, [[0.5, 0.595], [0.5, 0.735]], 0.018);
        return ((lobeL || lobeR || lowerBody || tip) && !cleft) ? 1 : 0;
      }
      if (lessonIndex === 2) {
        const a = Math.hypot(xn - 0.5, yn - 0.68) < 0.12;
        const b = Math.hypot(xn - 0.5, yn - 0.55) < 0.1;
        const c = Math.hypot(xn - 0.5, yn - 0.43) < 0.08;
        return (a || b || c) ? 1 : 0;
      }
      if (lessonIndex === 3) {
        const stem = Math.abs(xn - 0.5) < 0.03 && yn > 0.34 && yn < 0.74;
        const wave = Math.sin((yn - 0.34) * 36) * 0.085;
        const leaf = Math.abs(xn - (0.5 + wave)) < 0.05 && yn > 0.35 && yn < 0.74;
        return (stem || leaf) ? 1 : 0;
      }
      let wing = false;
      for (let k = 0; k < 7; k++) {
        const t = k / 6;
        const cx = 0.40 + Math.sin(t * 7.2) * 0.045;
        const cy = 0.69 - t * 0.27;
        const rx = 0.07 - t * 0.012;
        const ry = 0.05 - t * 0.009;
        if (inEllipse(xn, yn, cx, cy, rx, ry)) {
          wing = true;
          break;
        }
      }

      const belly = inEllipse(xn, yn, 0.46, 0.66, 0.12, 0.085);
      const neckCurve = inThickPolyline(
        xn, yn,
        [[0.46, 0.61], [0.50, 0.56], [0.57, 0.47], [0.61, 0.39], [0.60, 0.33]],
        0.022
      );
      const head = inEllipse(xn, yn, 0.615, 0.315, 0.038, 0.034);
      const beak = inThickPolyline(xn, yn, [[0.644, 0.312], [0.675, 0.304]], 0.010);
      const eyeCut = inEllipse(xn, yn, 0.61, 0.304, 0.011, 0.008);
      return ((wing || belly || neckCurve || head || beak) && !eyeCut) ? 1 : 0;
    }

    function rebuildTargetCache() {
      targetCache = new Uint8Array(grid.w * grid.h);
      for (let y = 0; y < grid.h; y++) {
        for (let x = 0; x < grid.w; x++) {
          const i = idx(x, y);
          targetCache[i] = targetMask(x / (grid.w - 1), y / (grid.h - 1));
        }
      }
    }

    function resetCup() {
      grid.brown.fill(0.88);
      grid.white.fill(0);
      state.rhythmBonus = 0;
      recalcScore();
      renderCup();
    }

    function resize() {
      const rect = cupWrap.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * state.dpr);
      canvas.height = Math.floor(rect.height * state.dpr);
      canvas.style.width = rect.width + "px";
      canvas.style.height = rect.height + "px";
      renderCup();
    }

    function pourAt(gx, gy, dt) {
      const base = 1.2 + state.pourFlow * 7.2;
      const radius = Math.max(1.6, 1.15 + state.pourFlow * 4.9 - Math.abs(state.tilt) * 2.6);
      const jitter = (1 - state.milkQuality) * 0.7;

      const minX = Math.max(1, Math.floor(gx - radius * 1.9));
      const maxX = Math.min(grid.w - 2, Math.ceil(gx + radius * 1.9));
      const minY = Math.max(1, Math.floor(gy - radius * 1.9));
      const maxY = Math.min(grid.h - 2, Math.ceil(gy + radius * 1.9));

      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const dx = x - gx + (Math.random() - 0.5) * jitter;
          const dy = y - gy;
          const d = Math.hypot(dx, dy);
          if (d > radius) continue;

          const falloff = 1 - d / radius;
          const push = base * falloff * dt;
          const i = idx(x, y);

          grid.white[i] = Math.min(1, grid.white[i] + push * 0.082);
          grid.brown[i] = Math.max(0.10, grid.brown[i] - push * 0.056);

          const driftX = Math.round(state.tilt * 2.8 * (0.35 + state.pourFlow));
          const ni = idx(clamp(x + driftX, 0, grid.w - 1), y);
          grid.white[ni] = Math.min(1, grid.white[ni] + push * 0.025);
        }
      }
    }

    function simulate(dt) {
      const diff = 0.043;
      const adv = state.tilt * 0.52;
      for (let y = 1; y < grid.h - 1; y++) {
        for (let x = 1; x < grid.w - 1; x++) {
          const i = idx(x, y);
          const l = idx(x - 1, y);
          const r = idx(x + 1, y);
          const u = idx(x, y - 1);
          const d = idx(x, y + 1);

          const lapW = grid.white[l] + grid.white[r] + grid.white[u] + grid.white[d] - grid.white[i] * 4;
          const lapB = grid.brown[l] + grid.brown[r] + grid.brown[u] + grid.brown[d] - grid.brown[i] * 4;

          let nw = grid.white[i] + lapW * diff * dt * 60;
          let nb = grid.brown[i] + lapB * diff * dt * 60;

          const from = idx(clamp(x - Math.round(adv), 0, grid.w - 1), y);
          nw = nw * 0.86 + grid.white[from] * 0.14;

          grid.nextWhite[i] = clamp(nw * 0.998, 0, 1);
          grid.nextBrown[i] = clamp(nb * 0.999, 0, 1);
        }
      }

      for (let y = 1; y < grid.h - 1; y++) {
        for (let x = 1; x < grid.w - 1; x++) {
          const i = idx(x, y);
          grid.white[i] = grid.nextWhite[i];
          grid.brown[i] = grid.nextBrown[i];
        }
      }
    }

    function recalcScore() {
      let hit = 0;
      let target = 0;
      let extra = 0;

      for (let y = 0; y < grid.h; y += 2) {
        for (let x = 0; x < grid.w; x += 2) {
          const i = idx(x, y);
          const t = targetCache[i];
          const isWhite = grid.white[i] > 0.24;
          if (t) {
            target++;
            if (isWhite) hit++;
          } else if (isWhite) {
            extra++;
          }
        }
      }

      const acc = target > 0 ? hit / target : 0;
      const penalty = Math.min(0.42, extra / (target + 1));
      const base = Math.max(0, (acc - penalty) * 100);
      state.score = Math.round(clamp(base + state.rhythmBonus, 0, 100));
      scoreChip.textContent = `Score: ${state.score}`;
    }

    function drawTargetOverlay() {
      const w = canvas.width;
      const h = canvas.height;
      ctx.save();
      ctx.globalAlpha = 0.14;
      ctx.fillStyle = "#f7e8cf";
      for (let y = 0; y < grid.h; y++) {
        for (let x = 0; x < grid.w; x++) {
          const i = idx(x, y);
          if (!targetCache[i]) continue;
          const px = (x / (grid.w - 1)) * w;
          const py = (y / (grid.h - 1)) * h;
          ctx.fillRect(px, py, (w / grid.w) * 1.2, (h / grid.h) * 1.2);
        }
      }
      ctx.restore();
    }

    function renderCup() {
      for (let y = 0; y < grid.h; y++) {
        for (let x = 0; x < grid.w; x++) {
          const i = idx(x, y);
          const p = i * 4;
          const white = grid.white[i];
          const brown = grid.brown[i];
          img.data[p] = Math.round(109 * brown + 248 * white);
          img.data[p + 1] = Math.round(61 * brown + 245 * white);
          img.data[p + 2] = Math.round(38 * brown + 236 * white);
          img.data[p + 3] = 255;
        }
      }

      offCtx.putImageData(img, 0, 0);
      ctx.imageSmoothingEnabled = true;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(offCanvas, 0, 0, canvas.width, canvas.height);
      drawTargetOverlay();

      if (state.pouring) {
        const px = (state.pointerX / (grid.w - 1)) * canvas.width;
        const py = (state.pointerY / (grid.h - 1)) * canvas.height;
        ctx.beginPath();
        ctx.arc(px, py, 7 * state.dpr, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255,255,255,0.82)";
        ctx.fill();
      }
    }

    function updateLesson() {
      lessonChip.textContent = `Lesson: ${lessons[lessonIndex]}`;
      rebuildTargetCache();
      recalcScore();
      renderCup();
    }

    function getTutorialPose(tNorm) {
      const p = clamp(tNorm, 0, 1);
      let x = 0.5;
      let y = 0.57;
      let flow = 0;
      let tilt = 0;
      let cue = "Hold neutral";

      if (lessonIndex === 0) {
        x = 0.5;
        y = 0.55;
        flow = p < 0.65 ? 0.62 : 0.18;
        tilt = 0;
        cue = p < 0.65 ? "Tilt forward and hold center" : "Lift slightly to finish";
      } else if (lessonIndex === 1) {
        if (p < 0.72) {
          const q = p / 0.72;
          x = 0.5 + Math.sin(q * Math.PI) * 0.045;
          y = 0.56 - q * 0.025;
          flow = 0.60;
          tilt = (x - 0.5) * 2.2;
          cue = "Set heart body with tight wiggle";
        } else {
          const q = (p - 0.72) / 0.28;
          x = 0.5;
          y = 0.54 + q * 0.20;
          flow = 0.22;
          tilt = 0;
          cue = "Lift and pull through to form the tip";
        }
      } else if (lessonIndex === 2) {
        const stage = Math.floor(p * 4);
        x = 0.5;
        y = 0.68 - stage * 0.12;
        flow = stage < 3 ? 0.58 : 0.22;
        if (stage === 3) y = 0.40 + (p * 4 - 3) * 0.28;
        cue = stage < 3 ? "Pulse down-up-down blobs" : "Finish with center pull-through";
      } else if (lessonIndex === 3) {
        x = 0.5 + Math.sin(p * 16 * Math.PI) * 0.09 * (1 - p * 0.35);
        y = 0.34 + p * 0.44;
        flow = p < 0.86 ? 0.54 : 0.22;
        tilt = clamp((x - 0.5) * 3.2, -1, 1);
        cue = p < 0.86 ? "Oscillate roll while moving down" : "Pull through center";
      } else {
        if (p < 0.58) {
          const q = p / 0.58;
          x = 0.42 + Math.sin(q * 12 * Math.PI) * 0.075 * (1 - q * 0.3);
          y = 0.68 - q * 0.22;
          flow = 0.56;
          tilt = clamp((x - 0.5) * 3.4, -1, 1);
          cue = "Wiggle wing (rosetta) from base upward";
        } else if (p < 0.83) {
          const q = (p - 0.58) / 0.25;
          x = 0.46 + q * 0.16;
          y = 0.58 - q * 0.25;
          flow = 0.34;
          tilt = clamp((x - 0.5) * 2.8, -1, 1);
          cue = "Lift and arc into the swan neck";
        } else {
          const q = (p - 0.83) / 0.17;
          x = 0.60 + q * 0.055;
          y = 0.33 - q * 0.018;
          flow = 0.20;
          tilt = clamp((x - 0.5) * 2.2, -1, 1);
          cue = "Finish head and beak with light draw-through";
        }
      }

      return { x, y, flow, tilt, cue };
    }

    function applyTutorialPolish(dt) {
      const speed = dt * 60;
      for (let i = 0; i < targetCache.length; i++) {
        if (targetCache[i]) {
          grid.white[i] = clamp(grid.white[i] + 0.0042 * speed, 0, 1);
          grid.brown[i] = clamp(grid.brown[i] - 0.0029 * speed, 0.1, 1);
        } else {
          grid.white[i] = clamp(grid.white[i] - 0.0016 * speed, 0, 1);
          grid.brown[i] = clamp(grid.brown[i] + 0.0012 * speed, 0.1, 1);
        }
      }
    }

    function updateTutorial(dt) {
      state.tutorialT += dt;
      const cycle = state.tutorialDuration;
      const phase = (state.tutorialT % cycle) / cycle;
      const pose = getTutorialPose(phase);

      state.pointerX = Math.round(clamp(pose.x * (grid.w - 1), 6, grid.w - 7));
      state.pointerY = Math.round(clamp(pose.y * (grid.h - 1), 8, grid.h - 9));
      state.pourFlow = pose.flow;
      state.pouring = pose.flow > 0.05;
      state.tilt = pose.tilt;
      state.rhythmBonus = 20;
      motionChip.textContent = `Tutorial: ${Math.round(phase * 100)}%`;
      hintPrimary.textContent = "Tutorial movement running (copy this phone motion)";
      hintSecondary.textContent = pose.cue;
    }

    function calibrateGrip() {
      if (state.beta == null || state.gamma == null) return;
      state.neutralBeta = state.beta;
      state.neutralGamma = state.gamma;
      state.rhythmFlips = 0;
      state.lastPitchSign = 0;
      if (navigator.vibrate) navigator.vibrate([15, 30, 15]);
    }

    function updatePitcherFromSensors(dt) {
      if (!state.pitcherEnabled || !state.sensorOk || state.beta == null || state.gamma == null) {
        state.pouring = false;
        state.pourFlow = 0;
        return;
      }

      const assist = Number(assistSlider.value) / 100;
      const betaRel = (state.beta - state.neutralBeta) * state.pourSign;
      const gammaRel = (state.gamma - state.neutralGamma) * state.rollSign;

      state.pointerX = Math.round(clamp(((gammaRel + 28) / 56) * (grid.w - 1), 6, grid.w - 7));
      state.pointerY = Math.round(clamp((0.68 - (betaRel / 80)) * (grid.h - 1), 8, grid.h - 9));

      const flowRaw = (betaRel - 4) / 22;
      state.pourFlow = clamp(flowRaw * (0.7 + assist * 0.8), 0, 1);
      state.pouring = state.pourFlow > 0.035;
      state.tilt = clamp(gammaRel / 26, -1, 1);

      if (state.pouring) {
        const sign = betaRel > 0 ? 1 : -1;
        if (state.lastPitchSign !== 0 && sign !== state.lastPitchSign && Math.abs(betaRel) > 8) {
          state.rhythmFlips++;
        }
        state.lastPitchSign = sign;
      }

      if (state.lastFlow > 0.08 && state.pourFlow <= 0.02) {
        if (state.rhythmFlips >= 2) {
          state.rhythmBonus = clamp(state.rhythmBonus + 4, 0, 20);
          if (navigator.vibrate) navigator.vibrate(12);
        }
        state.rhythmFlips = 0;
        state.lastPitchSign = 0;
      }

      state.lastFlow = state.pourFlow;
      motionChip.textContent = `Pitcher: On ${Math.round(state.pourFlow * 100)}%`;

      const rhythmMsg = state.rhythmBonus > 0 ? `Rhythm bonus +${state.rhythmBonus}` : "Pump down-up-down for rhythm bonus";
      hintPrimary.textContent = "Phone is pitcher: tilt forward to pour";
      hintSecondary.textContent = rhythmMsg;
    }

    async function enablePitcher() {
      const hasOrientation = typeof DeviceOrientationEvent !== "undefined";
      if (!hasOrientation) {
        motionChip.textContent = "Pitcher: Unsupported";
        hintPrimary.textContent = "This device/browser does not expose motion sensors";
        return;
      }

      const needsPermission = typeof DeviceOrientationEvent.requestPermission === "function";
      if (needsPermission) {
        try {
          const orientation = await DeviceOrientationEvent.requestPermission();
          if (orientation !== "granted") return;
        } catch (_) {
          return;
        }
      }

      state.pitcherEnabled = true;
      state.sensorOk = true;
      motionChip.textContent = "Pitcher: On";
      pitcherBtn.textContent = "Pitcher Active";
      hintPrimary.textContent = "Hold phone like a pitcher and tap Calibrate Grip";
      hintSecondary.textContent = "Then tilt forward/back and roll left/right";
    }

    function bindSensors() {
      window.addEventListener("deviceorientation", (e) => {
        if (typeof e.beta === "number") state.beta = e.beta;
        if (typeof e.gamma === "number") state.gamma = e.gamma;
      }, true);
    }

    function loop(now) {
      const dt = Math.min(0.04, (now - state.lastTime) / 1000);
      state.lastTime = now;

      if (state.tutorialActive) {
        updateTutorial(dt);
      } else {
        updatePitcherFromSensors(dt);
      }

      if (state.pouring) {
        pourAt(state.pointerX, state.pointerY, dt * 60);
      }

      simulate(dt);
      if (state.tutorialActive) applyTutorialPolish(dt);
      if ((now % 420) < 16) recalcScore();
      renderCup();
      requestAnimationFrame(loop);
    }

    pitcherBtn.addEventListener("click", enablePitcher);
    calibrateBtn.addEventListener("click", calibrateGrip);
    flipRollBtn.addEventListener("click", () => {
      state.rollSign *= -1;
      if (navigator.vibrate) navigator.vibrate(10);
      hintSecondary.textContent = `Roll direction flipped (${state.rollSign > 0 ? "normal" : "reversed"})`;
    });
    flipPourBtn.addEventListener("click", () => {
      state.pourSign *= -1;
      if (navigator.vibrate) navigator.vibrate(10);
      hintSecondary.textContent = `Pour direction flipped (${state.pourSign > 0 ? "normal" : "reversed"})`;
    });
    clearBtn.addEventListener("click", resetCup);

    prevBtn.addEventListener("click", () => {
      lessonIndex = (lessonIndex - 1 + lessons.length) % lessons.length;
      updateLesson();
    });
    tutorialBtn.addEventListener("click", () => {
      state.tutorialActive = !state.tutorialActive;
      state.tutorialT = 0;
      tutorialBtn.textContent = state.tutorialActive ? "Stop Tutorial" : "Start Tutorial";
      if (state.tutorialActive) {
        resetCup();
        motionChip.textContent = "Tutorial: 0%";
      } else {
        state.pouring = false;
        state.pourFlow = 0;
        motionChip.textContent = state.pitcherEnabled ? "Pitcher: On" : "Pitcher: Off";
        hintPrimary.textContent = "Tap \"Enable Pitcher\" then calibrate neutral grip";
        hintSecondary.textContent = "Tilt forward to pour, roll left-right to draw";
      }
    });

    nextBtn.addEventListener("click", () => {
      lessonIndex = (lessonIndex + 1) % lessons.length;
      updateLesson();
    });

    window.addEventListener("resize", resize);

    offCanvas.width = grid.w;
    offCanvas.height = grid.h;
    bindSensors();
    rebuildTargetCache();
    resetCup();
    resize();
    updateLesson();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
